# 1. Simple Identifier

The most straightforward way to define an identifier is by using the @Id annotation.

Simple ids are mapped using @Id to a single property of one of these types: Java primitive and primitive wrapper types,
String, Date, BigDecimal and BigInteger.

Let's see a quick example of defining an entity with a primary key of type long:

<hr/>

Hibernateda Simple idefikatorni @Id annotatsiyasidan foydalangan holda begliashimiz mumkin.
@Id annotatsiyasi ushbu typelar bilan ishlatishimiz mumkin.

Java primative va primative wrappers, String, Date, BigDecimal va BigInteger.

# 2. Generated Identifiers

If we want to automatically generate the primary key value, we can add the @GeneratedValue annotation.

This can use four generation types: AUTO, IDENTITY, SEQUENCE and TABLE.

If we don't explicitly specify a value, the generation type defaults to AUTO.

<hr/>

Primary keyni avtomatik yaratmoqchi bo'lsak, @GeneratedValue annotatsiyasidan foydalanishimiz mumkin.

Primary keyni generatsiya qilishni 4xil typedan foydalanishimiz mumkin: AUTO, IDENITY, SEQUENCE va TABLE

Agar ushbu 4xil typedan birotasini tanlamasak, default @GeneratedValue AUTO typeni oladi.

### 2.1 AUTO Generation

If we're using the default generation type, the persistence provider will determine values based on the type of the
primary key attribute. This type can be numerical or UUID.

For numeric values, the generation is based on a sequence or table generator, while UUID values will use the
UUIDGenerator.

<hr/>

Agar @GeneratedValue annotatsiyasini AUTO typedan foydalanvotgan bo'lsak persistence provider valuesini primary keyni
atributni typega qarab aniqlaydi. Ushbu typeda raqam yoki UUID bo'lishi mumkin.

+ Raqamlarni generatsiya qilish ushbu table sequenceiga yoki table generatoriga asoslanadi.
+ UUID valuesini generatsiay qilish UUIDGenerator tomonidan amalga oshiriladi.

```java

@Entity
public class Student {

    @Id
    @GeneratedValue
    private long studentId;

    // ...
}
```

Bunday holatda, primary key valuelari database levelda unique bo'ladi

`UUIDGenerator` Hibernate 5 versiyasidan boshlab qoshilgan.
Ushbu xususiyatdan @Id va @GeneratedValue bilan UUID typega e'lon qilish orqali foydalanishimiz mumkin.

```java

@Entity
public class Course {

    @Id
    @GeneratedValue
    private UUID courseId;

    // ...
}
```

Hibernate "8dd5f315-9788-4d00-87bb-10eed9eff566" shunday ko'rinishda identifikatorni yaratadi.

### 2.2 IDENTITY Generation

This type of generation relies on the IdentityGenerator, which expects values generated by an identity column in the
database. This means they are auto-incremented.

<hr/>

@GeneratedValue annotatsiyasni IDENTITY strategiyasidan foydalansak `IdentityGenerator` dan foydalangan holda
valueni generatsiya qiladi.

```java

@Entity
public class Student {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long studentId;

    // ...
}
```

Eslatma! ushbu strategiyadan foydalansak globalniy update o'chirib qoyadi. Yani biz primary keyni valuesini yangilay
olmaymiz.

### 2.3 SEQUENCE Generation

To use a sequence-based id, Hibernate provides the SequenceStyleGenerator class.

This generator uses sequences if our database supports them. It switches to table generation if they aren't supported.

In order to customize the sequence name, we can use the @GenericGenerator annotation with SequenceStyleGenerator
strategy:

<hr/>

@GeneratedValue annotatsiyasidan foydalansak Hibernate SequenceStyleGenerator classi tomonidan value generatsiya qiladi.
Agar bizni Database sequence yaratishni qo'llab quvvatlasa.

Sequence yaratishi o'zimiz hohlagandek qilib sozlashimiz ham mumkin buning uchun bizga @GenericGenerator
annotatsiyasidan
foydalangan holda amalga oshirishimiz mumkin.

```java

@Entity
public class User {
    @Id
    @GeneratedValue(generator = "sequence-generator")
    @GenericGenerator(
            name = "sequence-generator",
            strategy = "org.hibernate.id.enhanced.SequenceStyleGenerator",
            parameters = {
                    @Parameter(name = "sequence_name", value = "user_sequence"),
                    @Parameter(name = "initial_value", value = "4"),
                    @Parameter(name = "increment_size", value = "1")
            }
    )
    private long userId;

    // ...
}
```

In this example, we've also set an initial value for the sequence, which means the primary key generation will start at

4.

The generated values are unique per sequence.

<hr/>

Ushbu tepadagi misolda biz sequence uchun boshlang'ich qiymatni ham berdik, ya'ni primary key yaratish 4 dan boshlanadi.
Yaratilgan sequence unique bo'ladi.

### 2.4 TABLE Generation

The TableGenerator uses an underlying database table that holds segments of identifier generation values.

In this example, we can see that we can also customize other attributes such as the pkColumnName and valueColumnName.

However, the disadvantage of this method is that it doesn't scale well and can negatively affect performance.

To sum up, these four generation types will result in similar values being generated but use different database
mechanisms.

<hr/>

TableGenerator identifikatorga value generatsiya qilish uchun segmentlarni o'z ichiga olgan database tabledan
foydalanadi.

Ushbu misolda biz pkColumnName va valueColumnName kabi boshqa atributlarni ham sozlashimiz mumkinligini ko'rishimiz
mumkin .

Biroq, bu usulning kamchiligi shundaki, u yaxshi miqyosda emas va ishlashga salbiy ta'sir ko'rsatishi mumkin.

Xulosa qilib aytganda, ushbu to'rtta generation typei o'xshash qiymatlarni yaratishga olib keladi,
ammo databasening turli mexanizmlaridan foydalanadi.

```java
@Entity
public class Department {
    @Id
    @GeneratedValue(strategy = GenerationType.TABLE, 
      generator = "table-generator")
    @TableGenerator(name = "table-generator", 
      table = "dep_ids", 
      pkColumnName = "seq_id", 
      valueColumnName = "seq_value")
    private long depId;

    // ...
}
```


